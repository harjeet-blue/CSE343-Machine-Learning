# -*- coding: utf-8 -*-
"""utils_har.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1YnRCZZtaYzFQxaXbzMsgUT-zalKVeryd
"""

import numpy as np
import math
import pandas as pd
import matplotlib.pyplot as plt
import random

class basic:
  def math_func(self,x,k,p):
    temp=(1-(x**2))**0.5
    temp = p*temp
    final = k+temp
    return final

  def choose_k(self):
    p = random.randint(0,10)
    if(p>5):
      return 0
    else:
      return 3

  def choose_sign(self):
    p = random.uniform(0,1)
    if(p>0.5):
      return -1
    else:
      return 1

  def assign_label(self,k,ar,index):
    if(k==0):
      ar[index][2] = 0
    else:
      ar[index][2] = 1
    return ar 

  def create_dataset(self,size):
    sign=0
    k=0
    ar=np.zeros(3*size).reshape(size,3)
    temp=0
    while(temp<size):
      ar[temp][0] = random.uniform(-1,1)
      k = self.choose_k()
      ar = self.assign_label(k,ar,temp)
      sign = self.choose_sign()
      # print(k,sign)
      ar[temp][1] = self.math_func(ar[temp][0],k,sign)
      temp+=1
    return ar
  
  def check_zero(self,w):
    if(w==0):
      return 0.001
    else:
      return w
      
  def decision_boundary(self,x,w):
    intercept = -(w[0]/w[2])
    slope = (-w[1]/w[2])
    y = (slope*x) + intercept
    return y


  def graph_plot(self,data,q,w):
    
    x1=[]
    x2=[]
    y1=[]
    y2=[]

    if(q==0):
      for i in range(len(data)):
        if(data[i][2]==0):
          x1.append(data[i][0])
          y1.append(data[i][1])
        else:
          x2.append(data[i][0])
          y2.append(data[i][1])
      
      plt.scatter(x1, y1, color='b', label='0')
      plt.scatter(x2, y2, color='y', label='1')
      plt.xlabel("x")
      plt.ylabel("y")
      plt.title("Datapoints")
      plt.axhline(y=0, color='k')
      plt.axvline(x=0, color='k')
      plt.legend()
      plt.show()
      
    else:
      for i in range(len(data)):
        if(data[i][2]==-1):
            x1.append(data[i][0])
            y1.append(data[i][1])
        else:
          x2.append(data[i][0])
          y2.append(data[i][1])
      x = np.linspace(-1,1,200)
      if(w[2]==0):
        w[2]=-0.01
      y = ((-w[1]/w[2])*x) + (-w[0]/w[2])
      # y=(2*x) + 3

      plt.plot(x, y, '-r', label='Decision Boundary')
      plt.scatter(x1, y1, color='b', label='0')
      plt.scatter(x2, y2, color='y', label='1')
      plt.xlabel("x")
      plt.ylabel("y")
      plt.title("datapoints")
      plt.axhline(y=0, color='k')
      plt.axvline(x=0, color='k')
      plt.legend()

      # To load the display window
      plt.show()

  def signum(self,x):
    if(x>=0):
      return 1
    return -1
  
  def alter_label(self,data):
    # d = data
    for i in range(len(data)):
      if(data[i][2] ==0):
        data[i][2]=-1
    return data
  def calc_error(self,d,index,w):
    x1=d[index][0]
    x2=d[index][1]
    true=d[index][2]
    y = self.signum(w[0]+(w[1]*x1)+(w[2]*x2))
    return true-y
    
  def wt_update1(self,w,e,d,index):
    w[1:] = w[1:] + (e*d[index][0:2])
    w[0] = w[0] + e
    return w

  def wt_update2(self,w,e,d,index):
    w[1:] = w[1:] + (e*d[index][0:2])
    return w

  def PercepAlgo1(self,data,w):
    d=data
    for i in range(len(d)):
      if(d[i][2] ==0):
        d[i][2]=-1
    for j in range(1000):
      for i in range(len(d)):
        # print(d[i][2])
        e = d[i][2]-self.signum(w[0]+(w[1]*d[i][0])+(w[2]*d[i][1]))
        # print(e,"Error",w)
        if(e!=0):
          w[1:] = w[1:] + (e*d[i][0:2])
          w[0] = w[0] + e
          # print("Wt updated",w)
          
    return w

  def PercepAlgo2(self,data,w):
    d=data
    for i in range(len(d)):
      if(d[i][2] ==0):
        d[i][2]=-1
    for j in range(1000):
      for i in range(len(d)):
        e = d[i][2]-self.signum(w[0]+(w[1]*d[i][0])+(w[2]*d[i][1]))
        if(e!=0):
          w[1:] = w[1:] + (e*d[i][0:2])
    return w
  
  def generate_data_xor_or_and(self,i):
    d = np.array([[0,0,0],[0,1,0],[1,0,0],[1,1,0]])
    for j in range(4):
      if(i=='xor'):
        out = d[j][0] ^ d[j][1]
        d[j][2]=out
      elif(i=='or'):
        out = d[j][0] | d[j][1]
        d[j][2]=out
      elif(i=='and'):
        out = d[j][0] & d[j][1]
        d[j][2]=out

    return d

b = basic()
array = b.create_dataset(10000)

class dataset:
  def __init__(self):
    self.points = int(input("Datapoints: "))
  
  def addNoise(self,arr):
    noise = np.random.normal(0,0.1,1000)
    for i in range(len(arr)):
      index = random.randint(0,999)
      arr[i][0] += noise[index]
      arr[i][1] += noise[index]
    return arr

  def get(self,add_noise):
    size_of_array = self.points
    ar = np.zeros(size_of_array*3).reshape(size_of_array,3)
    flag = add_noise
    if(flag==False):
      for i in range(size_of_array):
        ar[i] = array[i]
    if(flag==True):
      copy = array
      copy = self.addNoise(copy)
      for i in range(size_of_array):
        ar[i] = copy[i]
    return ar

